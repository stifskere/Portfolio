use std::time::{Duration, SystemTimeError};
use std::sync::Arc;
use actix_error_proc::ActixError;
use base64::prelude::BASE64_URL_SAFE;
use base64::Engine;
use serde::{Deserialize, Serialize, Serializer};
use serde::ser::SerializeStruct;
use thiserror::Error;
use tokio::spawn;
use tokio::time::sleep;
use tokio::sync::Mutex;
use tokio::sync::broadcast::{channel, Receiver, Sender};
use crate::helpers::misc::expirable_object::{Expirable, ExpirableObject};
use reqwest::{Client as HttpClient, Error as ReqwestError, StatusCode};
use reqwest::header::{AUTHORIZATION, CONTENT_TYPE};
use serde_json::Error as JsonError;
use super::api_responses::{ApiSpotifyError, ApiSpotifySong, SongTimestamp, SpotifySong};

// TODO: Do not repeat the disconnected event
// TODO: permit event_from_poll send multiple events (to unpause when a song changes.)

/// A spotify poller error, used specifically
/// on the spotify poller as a generic error,
/// it should usually be used with the `?` operator.
#[derive(ActixError, Error, Debug)]
pub enum SpotifyPollerError {
    #[error("HTTP Request error: {0:#}")]
    Reqwest(#[from] ReqwestError),

    #[error("Spotify API abnormal response found {0:#}.")]
    Api(ApiSpotifyError),

    #[error("Time calculation error: \"{0:#}\".")]
    Time(#[from] SystemTimeError),

    // Since actix_web::Error is !Send, we need
    // to convert the error to a String manually.
    #[error("A WebSocket error occurred: {0}")]
    Ws(String),

    #[error("A Serialization error occurred: {0:#}")]
    Json(#[from] JsonError),

    #[error("An error occurred while subscribing to the poller: {0}")]
    #[http_status(NotAcceptable)]
    Subscription(String)
}

/// A SpotifyEvent is a serializable event
/// that describes what's happening currently,
/// to avoid cluttering the network, the
/// only time an event will be received
/// by a client is when something actually
/// changes.
#[derive(Clone, Debug)]
pub enum SpotifyEvent {
    /// This event happens
    /// when the registered user
    /// pauses a song.
    ///
    /// The event stores the last
    /// timestamp for the current
    /// song, for syncronization
    /// purposes.
    SongPaused(SongTimestamp),

    /// This event happens
    /// when the registed user
    /// unpauses a song.
    ///
    /// The event stores the last
    /// timestamp for the current
    /// song, for syncronization
    /// purposes.
    SongUnpaused(SongTimestamp),

    /// This event happens
    /// when a new song starts
    /// playing or a first
    /// sync event happens
    /// when a song is playing.
    NewSong(Arc<SpotifySong>),

    /// This event happens
    /// when the spotify client
    /// disconnects or a first
    /// sync event happens
    /// and the client is disconnected.
    ClientDisconnected,

    /// This event represents
    /// an error, in this case
    /// the event loop can't "return"
    /// an error, thus it must be sent
    /// as an event.
    PollerError(Arc<String>)
}

/// This struct contains the necessary
/// information so the SpotifyPoller can
/// authorize in the spotify API.
///
/// All the data from this struct should
/// be ideally retrieved from environment
/// variables, these variables can be generated
/// by a script found in the root of the project.
///
/// The authorization inside the program is a late
/// authorization step, OAuth must be passed and
/// a refresh_token must be requested, this is because
/// the OAuth token expires and the refresh token
/// does not.
///
/// The application doesn't require any authorization
/// scopes (aka intents) from the API, the only
/// endpoint it calls is to know the current song
/// every 5 seconds.
pub struct SpotifyAuthorization {
    /// A refresh token is generated by
    /// the OAuth process and it is provided
    /// by the script found on the root of the
    /// project.
    pub refresh_token: String,

    /// The client ID can be found in your
    /// application control panel.
    pub client_id: String,

    /// The client secret can be found in your
    /// application control panel.
    pub client_secret: String
}

/// The poller status indicates what happens
/// when new clients are registered to this
/// poller.
#[derive(Debug)]
pub enum PollerStatus {
    /// If the status is Fresh it means
    /// this is the first client to connect.
    ///
    /// The connection receiving this status
    /// will start the thread.
    Fresh,

    /// If the status is Working it means
    /// clients already connected before
    /// and the poller is polling data.
    ///
    /// The client will be registered as
    /// another listener.
    Working(Arc<Mutex<Receiver<SpotifyEvent>>>),

    /// If the status is Errored it means
    /// that clients won't be able to connect.
    ///
    /// The client that generated this status
    /// must clear all the other clients.
    ///
    /// This status keeps the error message
    /// to return as error if another client
    /// attempts to connect with the status
    /// for the current poller being Errored.
    Errored(Arc<String>)
}

/// A spotify poller is a structure that should be
/// registered as a service, this structure is async
/// proof, there is a specific use to this structure.
///
/// When registered as a service this structure
/// must be used within a websocket context,
/// subscribe a websocket client to the poller
/// and make it receive events.
///
/// This poller sends every 5 seconds a request
/// to the spotify API, this request is syncronized
/// by all the clients, so there is not more than a
/// request every 5 seconds.
///
/// This structure is lazy, meaning that the song
/// data won't start rotating until the first request.
///
/// `main thread` refers as the thread where
/// the SpotifyPoller exists.
pub struct SpotifyPoller {
    /// This token starts existing when
    /// the first song request is made.
    ///
    /// As per the spotify rules this token
    /// expires every hour, so it has
    /// a rotation mechanism, that's why
    /// it's wrapped in an Expirable<T>.
    ///
    /// This token is meant to be modified
    /// by the event_loop thread, it's
    /// internally managed by the get_current_song
    /// method.
    access_token: Arc<Mutex<Expirable<String>>>,

    /// The refresh token may or may not change
    /// every renewal, the poller is prepared
    /// to receive or not receive a new refresh
    /// token with the capacity to rotate it on
    /// every renewal.
    ///
    /// The refresh token is used by the access_token
    /// rotation mechanism to get a new token
    /// when the old one is expired.
    ///
    /// This kinds of tokens never expire, unless
    /// the API rotates them, which depends
    /// on the authorization intents.
    refresh_token: Arc<Mutex<String>>,

    /// The current song updates for the
    /// first time when a user subscribes
    /// to the poller.
    ///
    /// The current song is managed by
    /// the event_loop thread, and looped
    /// every 5 seconds, this isn't wrapped
    /// by an expirable because the song doesn't
    /// expire in a fixed date, it just keeps
    /// rotating every 5 seconds as per the
    /// event loop process.
    ///
    /// The meere reason for the existence
    /// of this field is so new users can sync
    /// to the loop without waiting for a new event.
    current_song: Arc<Mutex<Option<Arc<SpotifySong>>>>,

    /// The client_id refers to a specific application
    /// in the spotify developers dashboard, this
    /// is used to identify that application
    /// on further requests made to the spotify API.
    ///
    /// The client ID is directly obtained
    /// from the SpotifyAuthorization struct
    /// in the constructor.
    ///
    /// This client_id instance is shared between
    /// the main thread and the event_loop thread
    /// but it does never mutate.
    client_id: Arc<String>,

    /// The client_secret is the secret related
    /// to the earlier specified client_id, it
    /// serves for authentication, on common endpoints
    /// such as for token renewal.
    ///
    /// The spotify secret is directly obtained
    /// from the SpotifyAuthorization struct
    /// in the constructor.
    ///
    /// This client_secret instance is shared
    /// between the main thread and the event_loop
    /// thread, but it does never mutate.
    client_secret: Arc<String>,

    /// This HTTP client is created along the
    /// SpotifyPoller instance, and it is shared
    /// between the main thread and the event_loop
    /// thread.
    ///
    /// It is used for the event_loop to request
    /// new songs and for the song request
    /// to rotate keys if required.
    http_client: Arc<HttpClient>,

    /// This status is saved as the poller
    /// usability, the status displays
    /// whether the poller should have the
    /// event_loop started, if the event_loop
    /// is already running or if the poller
    /// cannot be used anymore.
    poller_status: Arc<Mutex<PollerStatus>>,
}

impl SpotifyPoller {
    /// This function creates a new SpotifyPoller, the authorization
    /// process starts at a late step, where the OAuth has already
    /// been completed, due to token expiration rules defined by
    /// spotify themselves.
    ///
    /// For more information about the authorization process read
    /// the documentation of the SpotifyAuthorization struct.
    ///
    /// Since the SpotifyPoller is a lazy structure meaning that
    /// it doesn't start polling until a client is connected, this
    /// function creates a default empty instance.
    ///
    /// returns an instance of SpotifyPoller unless an error
    /// occurrs, in that case a generic SpotifyPollerError.
    pub fn new(auth: SpotifyAuthorization) -> Self {
        Self {
            access_token: Arc::new(Mutex::new(Expirable::new_expired())),
            current_song: Arc::new(Mutex::new(None)),
            refresh_token: Arc::new(Mutex::new(auth.refresh_token)),
            client_id: Arc::new(auth.client_id),
            client_secret: Arc::new(auth.client_secret),
            http_client: Arc::new(HttpClient::new()),
            poller_status: Arc::new(Mutex::new(PollerStatus::Fresh))
        }
    }

    fn basic_auth(&self) -> String {
        format!(
            "Basic {}",
            BASE64_URL_SAFE
                .encode(
                    format!("{}:{}", self.client_id, self.client_secret)
                )
        )
    }

    /// This private method allows the instance to
    /// get the current token or renew it if expired.
    ///
    /// returns a Result<String, SpotifyPollerError> where
    /// the success is a String containing the token and
    /// the error is a generic SpotifyPollerError.
    ///
    /// The function is not async proof, so the returned
    /// value must be proofed manually.
    ///
    /// returns a raw String containing the token
    /// whether it's new or the instance one,
    /// unless an error occurrs, in that case a generic
    /// SpotifyPollerError.
    async fn get_token(&self) -> Result<String, SpotifyPollerError> {
        // lock the access token for mutability,
        // the lock should be dropped at the end of this
        // call.
        let mut access_token = self.access_token.lock().await;

        // If a token already exists and is not expired
        // simply return that token.
        if let ExpirableObject::OnTime(access_token) = access_token.get()? {
            return Ok(access_token.to_string());
        }

        /// This is scoped as it isn't used
        /// anywhere else.
        #[derive(Deserialize)]
        struct RefreshTokenResponse {
            access_token: String,
            expires_in: u64,
            refresh_token: Option<String>
        }

        // If no token exists request a new one with the
        // refresh key stored on the instance.
        let response = self
            .http_client
            .post("https://accounts.spotify.com/api/token")
            .header(CONTENT_TYPE, "application/x-www-form-urlencoded")
            .header(AUTHORIZATION, self.basic_auth())
            .form(&[
                ("grant_type", "refresh_token"),
                ("refresh_token", &self.refresh_token.lock().await),
            ])
            .send()
            .await?;

        // If something didn't go well we instead
        // serialize the response as an error and
        // make a SpotifyPollerError from it.
        if !response.status().is_success() {
            return Err(SpotifyPollerError::Api(
                response
                    .json()
                    .await?
            ));
        }

        // Otherwise we overwrite response to
        // the serialized RefreshTokenResponse.
        let response = response
            .json::<RefreshTokenResponse>()
            .await?;

        // mutate the current access_token locked
        // memory address.
        *access_token = Expirable::new_relative(
            response.access_token.clone(),
            response.expires_in
        )?;

        // if a new refresh token exists lock and
        // re set the instance refresh token to
        // make another renewal.
        if let Some(refresh_token) = response.refresh_token {
            *self.refresh_token.lock().await = refresh_token;
        }

        // return the retreived access token.
        Ok(response.access_token)
    }

    /// The sole purpose of his method is to retrieve the
    /// stored instance state so clients don't need to wait
    /// for the next event to occurr to display the song that
    /// is currently playing if any is.
    ///
    /// The why this sends events instead of an actual
    /// state is to reuse code in the client side, this way
    /// the same code that is used to resume or pause the
    /// display in the client side is used to syncronize
    /// the same client with the poller.
    ///
    /// returns a queue of SpotifyEvents that should be sent
    /// in chain, that events will indicate the client
    /// how it should behave, unless an error occurrs.
    /// In that case a generic SpotifyPollerError.
    pub async fn sync(&self) -> Result<Vec<SpotifyEvent>, SpotifyPollerError> {
        Ok(match self.current_song.lock().await.as_ref() {
            Some(song) => {
                // if a song is playing we send
                // the playing song and an additional
                // event whether the song is paused
                // or unpaused.
                vec![
                    SpotifyEvent::NewSong(song.clone()),
                    if song.is_playing() {
                        SpotifyEvent::SongUnpaused(song.timestamp())
                    } else {
                        SpotifyEvent::SongPaused(song.timestamp())
                    }
                ]
            },
            None => {
                // if a song is not playing
                // we send a ClientDisconnected
                // event along a SongPaused
                // at 0:0.
                vec![
                    SpotifyEvent::ClientDisconnected,
                    SpotifyEvent::SongPaused(SongTimestamp::zero())
                ]
            }
        })
    }

    /// THIS FUNCTION IS A RAW SPOTIFY API CALL
    /// IT DOES NOT ACCOUNT FOR SONG EXPIRATION.
    ///
    /// This song fetches the player status from
    /// the spotify API, it obtains the token
    /// from the `get_token` meaning it rotates
    /// the token if necessary.
    ///
    /// returns an Option of a SpotifySong whether
    /// a song is currently playing or not, unless
    /// an error occurrs. In that case a generic
    /// SpotifyPollerError.
    async fn get_current_song(&self) -> Result<Option<SpotifySong>, SpotifyPollerError> {
        // We obtiain a fresh token from the instance
        // autherntication protocol.
        let token = self.get_token().await?;

        // We obtain the currently playing song
        // using that authentication token.
        let response = self
            .http_client
            .get("https://api.spotify.com/v1/me/player/currently-playing")
            .header(AUTHORIZATION, format!("Bearer {token}"))
            .send()
            .await?;

        // If something didn't go well we instead
        // serialize the response as an error and
        // make a SpotifyPollerError from it.
        if !response.status().is_success() {
            return Err(SpotifyPollerError::Api(
                response
                    .json()
                    .await?
            ));
        }

        // If the response is no content it means that
        // there is no client connected. (ignoring the body)
        if response.status() == StatusCode::NO_CONTENT {
            return Ok(None);
        }

        // At this point the response can only be 200
        // because of the previous `error_for_status`
        // call on the response, so we obtain
        // the deserialized JSON body.
        let response_body = response
            .json::<ApiSpotifySong>()
            .await?
            .into();

        // and return that JSON body.
        Ok(Some(response_body))
    }

    /// This private function is meant to run on a thread,
    /// it does not return anything, it solely sends events
    /// trough a sender in the parameters.
    async fn poller_task(_self: Arc<Self>, sender: Sender<SpotifyEvent>) {
        // we start an infinite loop for the
        // task to be repeated.
        loop {
            // we obtain a new song and match
            // whether obtaining the song didn't return
            // any error.
            //
            // If it returned an error we stop
            // the event loop and declare this as
            // an error.
            //
            // when this errors all the clients should
            // be disconnected.
            let new_song = match _self.get_current_song().await {
                Ok(new_song) => new_song.map(|new_song| Arc::new(new_song)),

                Err(err) => {
                    // If there is an error retrieving a new song,
                    // the event loop should stop, and all the connections
                    // should be disconnected.
                    let err_fmt = Arc::new(format!("{err:#}"));

                    // we ignore the send error because it doesn't matter
                    // if there isn't anyone connected. (literally most of the time)
                    sender.send(SpotifyEvent::PollerError(err_fmt.clone())).ok();

                    // we set the poller status to Errored after an error
                    // occurrs so no more clients can connect to the poller.
                    *_self.poller_status.lock().await = PollerStatus::Errored(err_fmt.clone());

                    // and break the event loop.
                    break;
                }
            };

            // we lock the current song for access
            // sake.
            let mut current_song = _self.current_song.lock().await;

            // If there wasn't any error and a new song
            // state was fetched, convert that state to an event
            if let Some(event) = SpotifySong::event_from_poll(current_song.clone(), new_song.clone()) {
                // we ignore the send error because it doesn't matter
                // if there isn't anyone connected.
                sender.send(event).ok();
            }

            // we replace the current
            // song with the newly fetched one
            // for the sake of updating
            // timestamps.
            *current_song = new_song;

            // we sleep this thread for 5 seconds
            // and fetch a new song again.
            sleep(Duration::from_secs(5)).await;
        }
    }

    /// This method can be used to obtain a receiver
    /// that receiver can be used to subscribe
    /// and unsubscribe new clients.
    ///
    /// The method is stateful, what it returns
    /// depends on what the poller state is.
    ///
    /// If the poller state is fresh it will
    /// start a new thread and then return
    /// a shared Receiver with the caller.
    ///
    /// If the poller is in working status
    /// if simply returns a shared Receiver.
    ///
    /// If the poller status is in Errored
    /// status it will return the shared
    /// error format in the Err() branch.
    ///
    /// After the first to this method `self`
    /// should not be mutated from outside
    /// the event loop in any way, otherwise
    /// you can expect concurrency errors,
    /// or non finishing async taks.
    pub async fn get_receiver(self: &Arc<Self>) -> Result<Arc<Mutex<Receiver<SpotifyEvent>>>, Arc<String>> {
        // We create a mutable locked binding
        // to poller_status, which mutates
        // if the status is fresh and the thread
        // started.
        let mut poller_status = self
            .poller_status
            .lock()
            .await;

        // We match the current poller status.
        match &*poller_status {
            // If the poller status is Errored
            // we return the shared error.
            //
            // This way the user doesn't have access
            // to the receiver and can't subscribe
            // to a poller that doesn't emit any events.
            PollerStatus::Errored(error) => Err(error.clone()),

            // If the poller status is Fresh
            // it means that nobody ever subscribed,
            // so we need to start the thread
            // first.
            PollerStatus::Fresh => {
                // We create the channel.
                let (sender, receiver) = channel::<SpotifyEvent>(100);

                // Move the sender to the task and
                // a shared reference to self.
                spawn(Self::poller_task(self.clone(), sender));

                // Create a shared reference to the receiver
                let receiver = Arc::new(Mutex::new(receiver));
                // change the poller_status to working
                // and hold a reference to the receiver inside.
                *poller_status = PollerStatus::Working(receiver.clone());
                // and return a shared reference
                // to the receiver.
                Ok(receiver.clone())
            },

            // If the poller status was already working
            // we simply return a shared reference
            // to the receiver created when
            // the thread was instantiated
            // for the first time.
            PollerStatus::Working(receiver) => Ok(receiver.clone())
        }
    }
}

impl SpotifySong {
    /// This function makes the comparisons between two songs
    /// to check if an event should be sent to diferentiate
    /// both songs, in this case the songs should be the
    /// current song and a new poll.
    ///
    /// If the event is NewSong the song should be stored
    /// in the comparing SpotifyPoller instance, if the event
    /// is ClientDisconnected the song on the SpotifyPoller
    /// should be set to None.
    ///
    /// If this function returns None it means no event
    /// should be sent.
    ///
    /// returns Option<SpotifyEvent>, Some(_) if an event should
    /// be sent, otherwise None.
    pub fn event_from_poll(current: Option<Arc<Self>>, other: Option<Arc<Self>>) -> Option<SpotifyEvent> {
        // If the other song exists we
        // grab it, otherwise we assume
        // the client disconnected.
        let Some(other) = other
        else {
            return Some(SpotifyEvent::ClientDisconnected);
        };

        // If the current song doesn't
        // exist, but the other exists
        // since we passed the last step
        // it means there is a new song.
        let Some(current) = current
        else {
            return Some(SpotifyEvent::NewSong(other));
        };

        // We check if all the authors
        // from both songs are the same
        // and have the same length.
        let same_authors = current.authors()
            .iter()
            .all(|author| other.authors().contains(author))
            && current.authors().len() == other.authors().len();

        // If the title does not match or the authors
        // are not the same, we assume it's a new song.
        if current.title() != other.title() || !same_authors {
            return Some(SpotifyEvent::NewSong(other.clone()))
        }

        // If both songs don't have the same is_playing
        // status, it means there is a difference.
        if current.is_playing() != other.is_playing() {
            // We match the new song.
            return Some(match other.is_playing() {
                // If the new song is playing, since
                // the status aren't equal it means
                // the song was unpaused.
                true => SpotifyEvent::SongUnpaused(other.timestamp()),

                // If the new song is paused, since
                // the status aren't equal it means
                // the song was paused.
                false => SpotifyEvent::SongPaused(other.timestamp())
            })
        }

        // If no condition from above
        // matches it means no event
        // should be sent.
        None
    }
}

impl Serialize for SpotifyEvent {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        macro_rules! ss {
            ($event:literal, $data:expr) => {{
                let mut s = serializer.serialize_struct("SpotifyEvent", 2)?;
                s.serialize_field("event", $event)?;
                s.serialize_field("data", $data)?;
                s.end()
            }};
        }

        match self {
            Self::SongPaused(timestamp) => ss!("SongPaused", timestamp),

            Self::SongUnpaused(timestamp) => ss!("SongUnpaused", timestamp),

            Self::NewSong(song) => ss!("NewSong", song),

            Self::ClientDisconnected => ss!("ClientDisconnected", &None::<()>),

            Self::PollerError(error) => ss!("PollerError", error)
        }
    }
}
