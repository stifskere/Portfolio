use std::{borrow::Cow, time::SystemTimeError};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use crate::helpers::misc::expirable_object::{Expirable, ExpirableObject};
use reqwest::{header::{AUTHORIZATION, CONTENT_TYPE}, Client as HttpClient, Error as ReqwestError};

/// A spotify poller error, used specifically
/// on the spotify poller as a generic error,
/// it should usually be used with the `?` operator.
#[derive(Error, Debug)]
pub enum SpotifyPollerError {
    #[error("HTTP Request error: {0:#}")]
    Reqwest(#[from] ReqwestError),

    #[error("Spotify API abnormal response found.")]
    Api,

    #[error("Time calculation error: {0:#}")]
    Time(#[from] SystemTimeError)
}

/// This structure describes a spotify song author,
/// commonly refered as "artist" by the spotify
/// API itself.
///
/// The inside fields are not documented, because
/// they are raw spotify data in all cases.
#[derive(Deserialize, Serialize)]
pub struct SpotifyArtist {
    name: String,
    url: String
}

/// This structure describes a spotify song from a
/// "currenly playing" query, some of the names
/// being changed for sake of readability.
///
/// The inside fields are not documented, because
/// they are raw spotify data in all cases.
#[derive(Deserialize, Serialize)]
pub struct SpotifySong {
    #[serde(rename(deserialize = "artist"))]
    authors: Vec<SpotifyArtist>,

    #[serde(rename(deserialize = "album_image_url"))]
    image_url: String,

    title: String,
    song_url: String,

    is_playing: bool,
    #[serde(rename(deserialize = "time_played"))]
    played_time: u32,
    #[serde(rename(deserialize = "time_total"))]
    total_time: u32
}

/// A SpotifyEvent is a serializable event
/// that describes what's happening currently,
/// to avoid cluttering the network, the
/// only time an event will be received
/// by a client is when something actually
/// changes.
pub enum SpotifyEvent<'s> {
    /// This event happens
    /// when the registered user
    /// pauses a song.
    SongPaused,

    /// This event happens
    /// when the registed user
    /// unpauses a song.
    SongPlaying,

    /// This event happens
    /// when a new song starts
    /// playing or a first
    /// sync event happens
    /// when a song is playing.
    NewSong(&'s SpotifySong),

    /// This event happens
    /// when the spotify client
    /// disconnects or a first
    /// sync event happens
    /// and the client is disconnected.
    ClientDisconnected
}

/// This struct contains the necessary
/// information so the SpotifyPoller can
/// authorize in the spotify API.
///
/// All the data from this struct should
/// be ideally retrieved from environment
/// variables, these variables can be generated
/// by a script found in the root of the project.
///
/// The authorization inside the program is a late
/// authorization step, OAuth must be passed and
/// a refresh_token must be requested, this is because
/// the OAuth token expires and the refresh token
/// does not.
pub struct SpotifyAuthorization {
    /// A refresh token is generated by
    /// the OAuth process and it is provided
    /// by the script found on the root of the
    /// project.
    pub refresh_token: String,

    /// The client ID can be found in your
    /// application control panel.
    pub client_id: String,
}

/// The SpotifyPoller is a structure that should
/// be registered as a service, thus service being
/// used in the poller websocket, this way making
/// the requests to the server within a websocket.
///
/// The poller rotates an access token and uses it
/// to request what's currently playing in a period
/// of 5 seconds, all the websocket connections
/// must be syncronized to the poller, within a thread.
///
/// The syncronization is communicated trough a callback
/// that runs every time a song state change happens.
///
/// A song state change will happen when the song
/// title or is_playing state changes.
struct SpotifyPoller<'a> {
    /// The token starts existing on the
    /// first request, it's started
    /// as a default instance at first.
    access_token: Expirable<Cow<'a, String>>,

    /// The current song updates on the
    /// first request and remains updating
    /// until the client disconnects and
    /// this becomes None again.
    ///
    /// The event sent on the first
    /// sincronization depends
    /// on the value of this field.
    current_song: Option<SpotifySong>,

    /// The refresh token changes every renewal
    /// and it's always there, when the
    /// access token expires, it is used to
    /// request a new access token.
    refresh_token: String,

    /// The client_id refers to a specific application
    /// in the spotify developers dashboard, this
    /// is used to identify that application
    /// on further requests made to the spotify API.
    client_id: String,

    /// This http client is used to avoid instantiating
    /// many clients on every poll.
    http_client: HttpClient
}

impl<'a> SpotifyPoller<'a> {
    /// This function creates a new SpotifyPoller, the authorization
    /// process starts at a late step, where the OAuth has already
    /// been completed, due to token expiration rules defined by
    /// spotify themselves.
    ///
    /// For more information about the authorization process read
    /// the documentation of the SpotifyAuthorization struct.
    ///
    /// Since the SpotifyPoller is a lazy structure meaning that
    /// it doesn't start polling until a client is connected, this
    /// function creates a default empty instance.
    pub async fn new(auth: SpotifyAuthorization) -> Result<Self, SpotifyPollerError> {
        Ok(Self {
            access_token: Expirable::new_expired(),
            current_song: None,
            refresh_token: auth.refresh_token,
            client_id: auth.client_id,
            http_client: HttpClient::new()
        })
    }

    /// This private function allows the instance to
    /// get the current token or renew it if expired.
    ///
    /// returns a Result<String, SpotifyPollerError> where
    /// the success is a String containing the token and
    /// the error is a generic SpotifyPollerError.
    async fn get_token(&mut self) -> Result<String, SpotifyPollerError> {
        if let ExpirableObject::OnTime(access_token) = self.access_token.get()? {
            return Ok(access_token.to_string());
        }

        /// This is scoped as it isn't used
        /// anywhere else.
        #[derive(Deserialize)]
        struct RefreshTokenResponse {
            access_token: String,
            expires_in: u64,
            refresh_token: Option<String>
        }

        let response = self
            .http_client
            .post("https://accounts.spotify.com/api/token")
            .header(CONTENT_TYPE, "application/x-www-form-urlencoded")
            .form(&[
                ("grant_type", "refresh_token"),
                ("refresh_token", &self.refresh_token),
                ("client_id", &self.client_id)
            ])
            .send()
            .await?
            .error_for_status()
            .map_err(|_| SpotifyPollerError::Api)?
            .json::<RefreshTokenResponse>()
            .await?;

        self.access_token = Expirable::new_relative(
            Cow::Owned(response.access_token.clone()),
            response.expires_in
        )?;

        if let Some(refresh_token) = response.refresh_token {
            self.refresh_token = refresh_token;
        }

        Ok(response.access_token)
    }

    /// This function syncs new clients with the current
    /// poller status, as described in the SpotifyPoller
    /// documentation, this returns a status based
    /// on the &self.current_song value.
    ///
    /// returns a Result<SpotifyEvent, SpotifyPollerError>
    /// where the success is one of SpotifyEvent::NewSong
    /// if a song is playing and SpotifyEvent::ClientDisconnected
    /// if there is no song playing, on error it returns a generic
    /// SpotifyPollerError.
    pub async fn sync(&self) -> Result<SpotifyEvent, SpotifyPollerError> {
        Ok(match &self.current_song {
            Some(song) => SpotifyEvent::NewSong(song),
            None => SpotifyEvent::ClientDisconnected
        })
    }

    /// This function gets the current player status
    /// on each call, calls to this method are not
    /// rate-limit proof, so the function must be used
    /// inside a controlled event loop.
    ///
    /// The function also triggers a token rotation
    /// if neccessary thus why it requires mutability.
    ///
    /// returns a Result<SpotifySong, SpotifyPollerError> where the
    /// success is a SpotifySong instance containing the currently
    /// playing song, on error it returns a generc SpotifyPollerError.
    async fn get_current_song(&mut self) -> Result<SpotifySong, SpotifyPollerError> {
        let token = self.get_token().await?;

        let response = self
            .http_client
            .get("https://api.spotify.com/v1/me/player/currently-playing")
            .header(AUTHORIZATION, format!("Bearer {token}"))
            .send()
            .await?
            .error_for_status()
            .map_err(|_| SpotifyPollerError::Api)?
            .json()
            .await?;

        Ok(response)
    }
}
